# agents.md

## 两个关键文件路径：
- service worker (/source/volantis-sw.js)
- listener (/source/js/sw-update-listener.js)

## Volantis Service Worker – 最终设计目标

### 1. 核心理念

我们的 Service Worker 不是一个“缓存脚本”。
它是网站的离线中枢、版本协调者、资源调度器。

目标不是“缓存更多”，
而是：

* 页面永远快速响应
* 更新过程可感知
* 版本切换可控
* 用户体验平滑

我们拒绝“刷新一下就好”的玄学更新。
更新必须是可追踪、可解释、可验证的。

---

### 2. 架构目标

#### 2.1 双层缓存结构

* **Precache（版本绑定）**

  * 与构建版本强绑定
  * 每次构建生成独立缓存命名空间
  * 保证版本原子性
  * 激活时清理旧版本

* **Runtime（动态缓存）**

  * 用于图片 / CSS / JS 等静态资源
  * 提高命中率
  * 不影响版本主结构

我们追求“版本隔离”，而不是“缓存叠加”。

---

### 3. 后台更新机制

#### 3.1 更新原则

* 更新不阻塞页面
* 更新有进度
* 更新完成后再通知
* 用户决定是否切换版本

#### 3.2 更新流程

1. 前端发送 `FORCE_UPDATE`
2. SW 抓取新首页
3. 解析出所有静态资源
4. 批量并发缓存（带进度推送）
5. 通知 `NEW_VERSION_CACHED`
6. 用户触发 `SKIP_WAITING`
7. 激活并刷新

更新必须是“感知式”的，而不是静默替换。

---

### 4. 性能目标

* CDN 竞速（多源 race）
* 小批量并发（避免资源耗尽）
* 音频资源绕过 SW（避免 Range 断流）
* SW 自身 listener 永远直连网络（避免被缓存污染）

SW 不应该成为瓶颈。

---

### 5. 与前端的协作原则

SW 不控制 UI。
SW 只发送状态。

前端决定：

* 是否展示进度条
* 是否弹出更新提示
* 何时刷新

SW 的职责是状态机。
前端的职责是表达层。

---

### 6. 与 PJAX 的兼容目标

* 更新后通过 `controllerchange` 触发整页刷新
* 不依赖传统硬刷新
* 不缓存 listener 脚本
* 不干扰局部路由

SW 是全局层，PJAX 是视图层。
二者解耦。

---

### 7. 版本一致性原则

* 每次构建生成唯一版本号
* 激活阶段删除旧缓存
* 不允许跨版本混用资源

宁可重新下载，也不允许版本污染。

---

### 8. 我们不追求的东西

* 不做复杂数据库
* 不做离线内容编辑
* 不做无意义的缓存统计
* 不做“看起来很高级”的功能堆叠

复杂性必须为稳定性服务，否则拒绝。

---

### 9. 最终愿景

这个 Service Worker 应该做到：

* 首屏快速
* 更新透明
* 切换可控
* 日志可追踪
* 架构可维护

它不应神秘。
它应可推理、可调试、可进化。

当我们未来重构时，可以问自己一句话：

> 它是否让版本行为更清晰了？
> 还是只是让逻辑更复杂了？

如果是后者，回滚。

太好了。
那我们把这部分“时间观”正式写进设计宣言里，让它成为约束，而不是聊天时的灵感。

下面是**追加内容**，可以直接补充到 `agents.md` 末尾。

---

## 10. 关于 Stale-While-Revalidate 的立场

我们明确选择：

* 首页使用 Stale-While-Revalidate
* Bing 壁纸使用 Stale-While-Revalidate

这是一种取舍。

我们优先保证：

> 页面立即可用
> 然后再变新

而不是等待资源完整后才渲染。

但我们必须清醒地认识到：

SWR 的前提是 —— 后台更新机制必须稳定。

如果后台更新不可靠，SWR 会退化为“永久陈旧”。

---

## 11. 新鲜度优先原则

在本项目中，优先级排序为：

速度 > 新鲜度 > 完整性 > 极端离线能力

这意味着：

* 首页允许短时间使用旧内容
* 但不允许长期停留在旧版本
* 不允许“刷新后仍是旧版本”的状态
* 不允许刷新按钮失效

如果版本不同，第二次访问必须能够拿到新资源。

---

## 12. 严禁的情况

以下情况在设计层面被视为严重错误：

* HTML 被 runtime 长期缓存
* 跨版本混用资源（旧 HTML + 新 JS）
* listener 脚本被缓存
* 激活后旧 cache 未清理
* HTTP cache 与 SW cache 叠加导致假更新
* 用户点击刷新但版本未切换

我们宁可重新下载，也不允许版本污染。

---

## 13. 更新的可靠性要求

后台更新必须满足：

* 首页 fetch 使用 `cache: 'no-store'`
* 版本号强绑定 cache 命名空间
* activate 阶段清理旧版本 cache
* 更新状态单向推进（不可回退）
* 前端刷新按钮必须可绕过 runtime 缓存

前端刷新行为必须是“核按钮”。

即便 SW 出现异常，浏览器也能接管。

---

## 14. 半更新是最大的敌人

真正危险的不是旧版本。

真正危险的是：

旧 HTML + 新 JS
或
新 HTML + 旧 CSS

这种“撕裂状态”。

设计必须确保版本原子性。

---

## 15. 时间协调原则

Service Worker 是网站与“时间”之间的协调器。

Stale-While-Revalidate 是对时间的妥协。
但妥协必须可控。

当用户刷新时：

* 要么明确还是旧版本
* 要么明确已经切换

不能模糊。

不能让用户怀疑。

---

当未来我们修改缓存策略时，应始终问：

> 这个改动是否让版本行为更清晰？
> 还是只是让逻辑更复杂？

如果答案是后者，应当回滚。

---

这份文档的意义不是说明代码怎么写。
而是防止我们在功能扩张中迷失方向。

软件不是为了展示技巧。
软件是为了控制混乱。

而 Service Worker，是整个网站和“时间”之间的协调器。
